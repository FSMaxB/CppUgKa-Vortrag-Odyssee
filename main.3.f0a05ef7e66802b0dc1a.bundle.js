(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{13:function(e,n,t){t(14),e.exports=t(49)},39:function(e,n,t){var a={"./00-title.md":40,"./01-introduction.md":41,"./02-beginnings.md":42,"./03-serialisation.md":43,"./04-migration.md":44,"./05-cpp-error-handling.md":45,"./06-cpp-serialisation.md":46,"./07-modern-cpp.md":47,"./08-end.md":48};function r(e){var n=l(e);return t(n)}function l(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=l,e.exports=r,r.id=39},40:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Odyssee von C nach C++, ein Reisebericht"),Object(l.a)("h2",null,"Max Bruckner"))}],s=[{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=u(e,["components"]);return Object(l.a)(p,c({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Odyssee von C nach C++, ein Reisebericht"),Object(l.a)("h2",null,"Max Bruckner"))}b.isMDXComponent=!0},41:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Worum gehts?"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("a",u({parentName:"li"},{href:"https://github.com/1984Not-GmbH/molch"}),"Molch"),"-Library"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("a",u({parentName:"li"},{href:"https://signal.org/docs/specifications/doubleratchet/"}),"Double Ratchet"),"-Implementierung",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"Krypto-Messenger-Protokoll"),Object(l.a)("li",{parentName:"ul"},"ehemals Axolotl"))),Object(l.a)("li",{parentName:"ul"},"Projektstart: Mitte 2015")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Anforderungen"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Plattformübergreifend",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"Desktop"),Object(l.a)("li",{parentName:"ul"},"Android"),Object(l.a)("li",{parentName:"ul"},"iOS"))),Object(l.a)("li",{parentName:"ul"},"Keys sicher im Speicher"),Object(l.a)("li",{parentName:"ul"},"State (de-)serialisierbar")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Sprachen"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Java"),Object(l.a)("li",{parentName:"ul"},"Go"),Object(l.a)("li",{parentName:"ul"},"Rust"),Object(l.a)("li",{parentName:"ul"},"C++"),Object(l.a)("li",{parentName:"ul"},"C")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Java"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"iOS? (-)"),Object(l.a)("li",{parentName:"ul"},"Speicher löschen? (-)"),Object(l.a)("li",{parentName:"ul"},"Garbage Collector? (-)"),Object(l.a)("li",{parentName:"ul"},"Speichersicher (+)")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Go"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"recht jung (-)"),Object(l.a)("li",{parentName:"ul"},"Speicher löschen? (-)"),Object(l.a)("li",{parentName:"ul"},"Cross-Kompilierung? (-)"),Object(l.a)("li",{parentName:"ul"},"Libraries? (-)"),Object(l.a)("li",{parentName:"ul"},"Speichersicher (+)")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Rust"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"extrem Jung (-)"),Object(l.a)("li",{parentName:"ul"},"Cross-Kompilierung? (-)"),Object(l.a)("li",{parentName:"ul"},"Libraries? (-)"),Object(l.a)("li",{parentName:"ul"},"Speichersicher (+)")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"C++"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"sehr Komplex (-)"),Object(l.a)("li",{parentName:"ul"},"unsicher (-)"),Object(l.a)("li",{parentName:"ul"},"plattformübergreifend (+)")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"C"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"unsicher (-)"),Object(l.a)("li",{parentName:"ul"},"plattformübergreifend (+)"),Object(l.a)("li",{parentName:"ul"},"einfach (+) 🤔")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Entscheidung"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"C/C++ damals alternativlos"),Object(l.a)("li",{parentName:"ul"},"C++ zu komplex"),Object(l.a)("li",{parentName:"ul"},"⇒ ",Object(l.a)("strong",{parentName:"li"},"C"))))}],s=[{sectionTitle:"Einführung",note:"* Persönliche Odyssee"},{},{sectionTitle:"Sprachen"},{},{},{note:"15. Mai 2015"},{},{},{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=c(e,["components"]);return Object(l.a)(p,u({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h2",null,"Worum gehts?"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("a",u({parentName:"li"},{href:"https://github.com/1984Not-GmbH/molch"}),"Molch"),"-Library"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("a",u({parentName:"li"},{href:"https://signal.org/docs/specifications/doubleratchet/"}),"Double Ratchet"),"-Implementierung",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"Krypto-Messenger-Protokoll"),Object(l.a)("li",{parentName:"ul"},"ehemals Axolotl"))),Object(l.a)("li",{parentName:"ul"},"Projektstart: Mitte 2015")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Anforderungen"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Plattformübergreifend",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"Desktop"),Object(l.a)("li",{parentName:"ul"},"Android"),Object(l.a)("li",{parentName:"ul"},"iOS"))),Object(l.a)("li",{parentName:"ul"},"Keys sicher im Speicher"),Object(l.a)("li",{parentName:"ul"},"State (de-)serialisierbar")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Sprachen"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Java"),Object(l.a)("li",{parentName:"ul"},"Go"),Object(l.a)("li",{parentName:"ul"},"Rust"),Object(l.a)("li",{parentName:"ul"},"C++"),Object(l.a)("li",{parentName:"ul"},"C")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Java"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"iOS? (-)"),Object(l.a)("li",{parentName:"ul"},"Speicher löschen? (-)"),Object(l.a)("li",{parentName:"ul"},"Garbage Collector? (-)"),Object(l.a)("li",{parentName:"ul"},"Speichersicher (+)")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Go"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"recht jung (-)"),Object(l.a)("li",{parentName:"ul"},"Speicher löschen? (-)"),Object(l.a)("li",{parentName:"ul"},"Cross-Kompilierung? (-)"),Object(l.a)("li",{parentName:"ul"},"Libraries? (-)"),Object(l.a)("li",{parentName:"ul"},"Speichersicher (+)")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Rust"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"extrem Jung (-)"),Object(l.a)("li",{parentName:"ul"},"Cross-Kompilierung? (-)"),Object(l.a)("li",{parentName:"ul"},"Libraries? (-)"),Object(l.a)("li",{parentName:"ul"},"Speichersicher (+)")),Object(l.a)("hr",null),Object(l.a)("h2",null,"C++"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"sehr Komplex (-)"),Object(l.a)("li",{parentName:"ul"},"unsicher (-)"),Object(l.a)("li",{parentName:"ul"},"plattformübergreifend (+)")),Object(l.a)("hr",null),Object(l.a)("h2",null,"C"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"unsicher (-)"),Object(l.a)("li",{parentName:"ul"},"plattformübergreifend (+)"),Object(l.a)("li",{parentName:"ul"},"einfach (+) 🤔")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Entscheidung"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"C/C++ damals alternativlos"),Object(l.a)("li",{parentName:"ul"},"C++ zu komplex"),Object(l.a)("li",{parentName:"ul"},"⇒ ",Object(l.a)("strong",{parentName:"li"},"C"))))}b.isMDXComponent=!0},42:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Erste Schritte"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Error Handling"),Object(l.a)("p",null,"❌ errno"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Error Handling"),Object(l.a)("p",null,Object(l.a)("strong",{parentName:"p"},"0 == Erfolg")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"int diffie_hellman(/* ... */) {\n  int status = 0;\n  /* ... */\n  status = crypto_scalarmult(/* ... */);\n  if (status != 0) {\n    return status;\n  }\n  /* ... */\n  return status;\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"⚠ Achtung"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"/* --\x3e */ diffie_hellman(/* ... */);\nif (status != 0) {\n  return status;\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Lösung"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"int diffie_hellman(/* ... */) __attribute__((warn_unused_result));\n")),Object(l.a)("h3",null,"C++ (17)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"[[nodiscard]] // Auch für Typen\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Bequemlichkeit"),Object(l.a)("p",null,"🙁"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"if (status != 0) {\n  return status;\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Bequemlichkeit"),Object(l.a)("p",null,"🙂"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define on_error if (status != 0)\n\non_error {\n  return status;\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Ressourcenverwaltung"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"char *buffer1 = malloc(size1);\n/* .. */\n\non_error {\n  free(buffer1);\n  return status;\n}\n\nchar *buffer2 = malloc(size2);\n\n/* .. */\n\non_error {\n  free(buffer1);\n  free(buffer2);\n  return status;\n}\n\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"⚠ Memory Leak"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-diff"}),"diff --git a/lib/message.c b/lib/message.c\nindex fb2f0d30d..60897128a 100644\n--- a/lib/message.c\n+++ b/lib/message.c\n@@ -152,6 +152,7 @@ int decrypt_message(\n                        key);\n        if (status != 0) {\n                sodium_memzero(plaintext_buffer, PLAINTEXT_LENGTH);\n+               free(plaintext_buffer);\n                return status;\n        }\n\n@@ -164,6 +165,7 @@ int decrypt_message(\n        //copy plaintext to message (output)\n        memcpy(message, plaintext_buffer, *message_length);\n        sodium_memzero(plaintext_buffer, PLAINTEXT_LENGTH);\n+       free(plaintext_buffer);\n\n        //copy header length to output\n        *header_length = HEADER_LENGTH;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Goto considered beneficial"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"char *buffer1 = NULL;\nchar *buffer2 = NULL;\n/* .. */\nbuffer1 = malloc(size1);\n/* .. */\non_error {\n  goto cleanup;\n}\nbuffer2 = malloc(size2);\n/* .. */\non_error {\n  goto cleanup;\n}\n/* .. */\ncleanup:\n  if (buffer1 != NULL) {\n    free(buffer1);\n  }\n  if (buffer2 != NULL) {\n    free(buffer2);\n  }\n\n  return status;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Mehr Bequemlichkeit"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define free_and_null(pointer)\\\n  free(pointer);\\\n  pointer = NULL;\n\n#define free_and_null_if_valid(pointer)\\\n  if (pointer != NULL) {\\\n    free_and_null(pointer)\\\n  }\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Mehr Bequemlichkeit"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"char *buffer1 = NULL;\nchar *buffer2 = NULL;\n/* .. */\nbuffer1 = malloc(size1);\n/* .. */\non_error {\n  goto cleanup;\n}\nbuffer2 = malloc(size2);\n/* .. */\non_error {\n  goto cleanup;\n}\n/* .. */\ncleanup:\n  free_and_null_if_valid(buffer1);\n  free_and_null_if_valid(buffer1); /* BUG verhindert (double free)! */\n  free_and_null_if_valid(buffer2);\n\n  return status;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Fehlertypen"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"typedef enum status_type {\n  SUCCESS = 0,\n  GENERIC_ERROR,\n  INVALID_INPUT,\n  INVALID_VALUE,\n  INCORRECT_BUFFER_SIZE,\n  /* ... */\n} status_type;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Let's get crazy"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Stacktraces (oder so ...)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"typedef struct error_message error_message;\nstruct error_message {\n  const char * message;\n  status_type status;\n  error_message *next; // <-- linked list\n};\n\ntypedef struct return_status {\n  status_type status;\n  error_message *error;\n} return_status;\n\nreturn_status return_status_init();\n\nstatus_type return_status_add_error_message(\n        return_status *const status_object,\n        const char *const message,\n        const status_type status) __attribute__((warn_unused_result));\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Stacktraces (oder so ...)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define throw(status_type_value, message) {\\\n    status.status = status_type_value;\\\n    if (message != NULL) {\\\n        status_type type = return_status_add_error_message(&status, message, status_type_value);\\\n        if (type != SUCCESS) {\\\n            status.status = type;\\\n        }\\\n    } else {\\\n        status.error = NULL;\\\n    }\\\n\\\n    goto cleanup;\\\n}\n\n#define on_error if (status.status != SUCCESS)\n\n#define throw_on_error(status_type_value, message) \\\n  on_error {\\\n    throw(status_type_value, message)\\\n  }\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Ergebnis"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),'return_status status = return_status_init();\nchar *buffer = NULL;\n\n/* ... */\nstatus = funktion();\nthrow_on_error(GENERIC_ERROR, "Aufruf ist fehlgeschlagen")\n\ncleanup:\n  free_and_null_if_valid(buffer);\n\n  return status;\n')))}],s=[{},{},{sectionTitle:"Error Handling"},{note:"return type nicht gecheckt"},{},{},{},{},{},{},{},{},{},{},{note:"Wer aus dem Publikum hat schon eine linked list implementiert?"},{note:"Kommt das &quot;keyword&quot; jemandem bekannt vor?"},{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=c(e,["components"]);return Object(l.a)(p,u({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Erste Schritte"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Error Handling"),Object(l.a)("p",null,"❌ errno"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Error Handling"),Object(l.a)("p",null,Object(l.a)("strong",{parentName:"p"},"0 == Erfolg")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"int diffie_hellman(/* ... */) {\n  int status = 0;\n  /* ... */\n  status = crypto_scalarmult(/* ... */);\n  if (status != 0) {\n    return status;\n  }\n  /* ... */\n  return status;\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"⚠ Achtung"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"/* --\x3e */ diffie_hellman(/* ... */);\nif (status != 0) {\n  return status;\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Lösung"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"int diffie_hellman(/* ... */) __attribute__((warn_unused_result));\n")),Object(l.a)("h3",null,"C++ (17)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"[[nodiscard]] // Auch für Typen\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Bequemlichkeit"),Object(l.a)("p",null,"🙁"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"if (status != 0) {\n  return status;\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Bequemlichkeit"),Object(l.a)("p",null,"🙂"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define on_error if (status != 0)\n\non_error {\n  return status;\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Ressourcenverwaltung"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"char *buffer1 = malloc(size1);\n/* .. */\n\non_error {\n  free(buffer1);\n  return status;\n}\n\nchar *buffer2 = malloc(size2);\n\n/* .. */\n\non_error {\n  free(buffer1);\n  free(buffer2);\n  return status;\n}\n\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"⚠ Memory Leak"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-diff"}),"diff --git a/lib/message.c b/lib/message.c\nindex fb2f0d30d..60897128a 100644\n--- a/lib/message.c\n+++ b/lib/message.c\n@@ -152,6 +152,7 @@ int decrypt_message(\n                        key);\n        if (status != 0) {\n                sodium_memzero(plaintext_buffer, PLAINTEXT_LENGTH);\n+               free(plaintext_buffer);\n                return status;\n        }\n\n@@ -164,6 +165,7 @@ int decrypt_message(\n        //copy plaintext to message (output)\n        memcpy(message, plaintext_buffer, *message_length);\n        sodium_memzero(plaintext_buffer, PLAINTEXT_LENGTH);\n+       free(plaintext_buffer);\n\n        //copy header length to output\n        *header_length = HEADER_LENGTH;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Goto considered beneficial"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"char *buffer1 = NULL;\nchar *buffer2 = NULL;\n/* .. */\nbuffer1 = malloc(size1);\n/* .. */\non_error {\n  goto cleanup;\n}\nbuffer2 = malloc(size2);\n/* .. */\non_error {\n  goto cleanup;\n}\n/* .. */\ncleanup:\n  if (buffer1 != NULL) {\n    free(buffer1);\n  }\n  if (buffer2 != NULL) {\n    free(buffer2);\n  }\n\n  return status;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Mehr Bequemlichkeit"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define free_and_null(pointer)\\\n  free(pointer);\\\n  pointer = NULL;\n\n#define free_and_null_if_valid(pointer)\\\n  if (pointer != NULL) {\\\n    free_and_null(pointer)\\\n  }\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Mehr Bequemlichkeit"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"char *buffer1 = NULL;\nchar *buffer2 = NULL;\n/* .. */\nbuffer1 = malloc(size1);\n/* .. */\non_error {\n  goto cleanup;\n}\nbuffer2 = malloc(size2);\n/* .. */\non_error {\n  goto cleanup;\n}\n/* .. */\ncleanup:\n  free_and_null_if_valid(buffer1);\n  free_and_null_if_valid(buffer1); /* BUG verhindert (double free)! */\n  free_and_null_if_valid(buffer2);\n\n  return status;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Fehlertypen"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"typedef enum status_type {\n  SUCCESS = 0,\n  GENERIC_ERROR,\n  INVALID_INPUT,\n  INVALID_VALUE,\n  INCORRECT_BUFFER_SIZE,\n  /* ... */\n} status_type;\n")),Object(l.a)("hr",null),Object(l.a)("h1",null,"Let's get crazy"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Stacktraces (oder so ...)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"typedef struct error_message error_message;\nstruct error_message {\n  const char * message;\n  status_type status;\n  error_message *next; // <-- linked list\n};\n\ntypedef struct return_status {\n  status_type status;\n  error_message *error;\n} return_status;\n\nreturn_status return_status_init();\n\nstatus_type return_status_add_error_message(\n        return_status *const status_object,\n        const char *const message,\n        const status_type status) __attribute__((warn_unused_result));\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Stacktraces (oder so ...)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define throw(status_type_value, message) {\\\n    status.status = status_type_value;\\\n    if (message != NULL) {\\\n        status_type type = return_status_add_error_message(&status, message, status_type_value);\\\n        if (type != SUCCESS) {\\\n            status.status = type;\\\n        }\\\n    } else {\\\n        status.error = NULL;\\\n    }\\\n\\\n    goto cleanup;\\\n}\n\n#define on_error if (status.status != SUCCESS)\n\n#define throw_on_error(status_type_value, message) \\\n  on_error {\\\n    throw(status_type_value, message)\\\n  }\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Ergebnis"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),'return_status status = return_status_init();\nchar *buffer = NULL;\n\n/* ... */\nstatus = funktion();\nthrow_on_error(GENERIC_ERROR, "Aufruf ist fehlgeschlagen")\n\ncleanup:\n  free_and_null_if_valid(buffer);\n\n  return status;\n')))}b.isMDXComponent=!0},43:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Serialisierung"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Protocol Buffers"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto2";\n\noption optimize_for = LITE_RUNTIME;\n\npackage Molch.Protobuf;\n\nmessage Key {\n  required bytes key = 1;\n}\n')))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Protobuf-C"),Object(l.a)("h3",null,"generierter Code"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"typedef struct _Molch__Protobuf__Key Molch__Protobuf__Key;\nstruct  _Molch__Protobuf__Key\n{\n  ProtobufCMessage base;\n  ProtobufCBinaryData key;\n};\n\nvoid   molch__protobuf__key__init(Molch__Protobuf__Key *message);\nsize_t molch__protobuf__key__get_packed_size(const Molch__Protobuf__Key *message);\nsize_t molch__protobuf__key__pack(const Molch__Protobuf__Key *message, uint8_t *out);\n/* ... */\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Keys löschen"),Object(l.a)("p",null,"❌ ",Object(l.a)("em",{parentName:"p"},"dead store elimination")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"memset(buffer, '\\0', buffer_size);\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Keys löschen"),Object(l.a)("p",null,"✅ gelöstes Problem"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"sodium_memzero(buffer, buffer_size);\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"sodium_malloc"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Allokiert 4 oder mehr Speicherseiten",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"Guard page davor"),Object(l.a)("li",{parentName:"ul"},"Nutz-Page"),Object(l.a)("li",{parentName:"ul"},"Guard page danach"))),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"sodium_memzero")," bei deallokation"),Object(l.a)("li",{parentName:"ul"},"❌ zu viele kleine Allokationen")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{}),"          page 1               page 2               page 3                     page n - 1     page n\n+-------------------------+------------+----------------------------+-- ... --+-----------+------------+\n| allocation_size | empty | guard page | empty | canary | user_data |   ...   | user_data | guard page |\n+-------------------------+------------+----------------------------+-- ... --+-----------+------------+\n^                                      ^       ^        ^\n|                                      | ------|--------| unprotected size ---------------|\nbase_ptr                 unprotected_ptr       |        user_ptr\n                                               canary_ptr\n")),Object(l.a)("p",null,Object(l.a)("a",u({parentName:"p"},{href:"https://github.com/jedisct1/libsodium/issues/572#issuecomment-319654932"}),"Aus einem GitHub-Kommentar von mir")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"zeroed_malloc"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Eigenimplementierung"),Object(l.a)("li",{parentName:"ul"},"Speichert Länge"),Object(l.a)("li",{parentName:"ul"},"Überschreibt beim deallokieren mit 0")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Erste tests auf ARM"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Erste tests auf ARM"),Object(l.a)("h3",null,"Program terminated with signal SIGBUS, Bus error."))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Alignment"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"void *next_aligned_address(void *pointer, size_t alignment){\n  //determine the amount of padding for proper alignment\n  size_t padding = 0; //padding needed to fit alignment\n  if (alignment != 0) {\n    padding = (alignment - (((size_t)pointer) % alignment)) % alignment;\n  }\n\n  return (char*)pointer + padding;\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Protobuf-C allocator"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"void *protobuf_c_allocator(void *allocator_data __attribute__((unused)), size_t size) {\n  return zeroed_malloc(size);\n}\n\nvoid protobuf_c_free(void *allocator_data __attribute__((unused)), void *pointer) {\n  zeroed_free(pointer);\n}\n\nstatic ProtobufCAllocator protobuf_c_allocators __attribute__((unused)) = {\n  &protobuf_c_allocator,\n  &protobuf_c_free,\n  NULL\n};\n")))}],s=[{sectionTitle:"Serialisierung"},{},{note:"Der Name ist noch nicht mal vom Standard erlaubt ..."},{},{},{},{},{},{note:"Vielleicht weiß jemand was jetzt kommt."},{},{},{note:"In C ist sowas relativ einfach"}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=c(e,["components"]);return Object(l.a)(p,u({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Serialisierung"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Protocol Buffers"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto2";\n\noption optimize_for = LITE_RUNTIME;\n\npackage Molch.Protobuf;\n\nmessage Key {\n  required bytes key = 1;\n}\n')),Object(l.a)("hr",null),Object(l.a)("h2",null,"Protobuf-C"),Object(l.a)("h3",null,"generierter Code"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"typedef struct _Molch__Protobuf__Key Molch__Protobuf__Key;\nstruct  _Molch__Protobuf__Key\n{\n  ProtobufCMessage base;\n  ProtobufCBinaryData key;\n};\n\nvoid   molch__protobuf__key__init(Molch__Protobuf__Key *message);\nsize_t molch__protobuf__key__get_packed_size(const Molch__Protobuf__Key *message);\nsize_t molch__protobuf__key__pack(const Molch__Protobuf__Key *message, uint8_t *out);\n/* ... */\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Keys löschen"),Object(l.a)("p",null,"❌ ",Object(l.a)("em",{parentName:"p"},"dead store elimination")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"memset(buffer, '\\0', buffer_size);\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Keys löschen"),Object(l.a)("p",null,"✅ gelöstes Problem"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"sodium_memzero(buffer, buffer_size);\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"sodium_malloc"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Allokiert 4 oder mehr Speicherseiten",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"Guard page davor"),Object(l.a)("li",{parentName:"ul"},"Nutz-Page"),Object(l.a)("li",{parentName:"ul"},"Guard page danach"))),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"sodium_memzero")," bei deallokation"),Object(l.a)("li",{parentName:"ul"},"❌ zu viele kleine Allokationen")),Object(l.a)("hr",null),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{}),"          page 1               page 2               page 3                     page n - 1     page n\n+-------------------------+------------+----------------------------+-- ... --+-----------+------------+\n| allocation_size | empty | guard page | empty | canary | user_data |   ...   | user_data | guard page |\n+-------------------------+------------+----------------------------+-- ... --+-----------+------------+\n^                                      ^       ^        ^\n|                                      | ------|--------| unprotected size ---------------|\nbase_ptr                 unprotected_ptr       |        user_ptr\n                                               canary_ptr\n")),Object(l.a)("p",null,Object(l.a)("a",u({parentName:"p"},{href:"https://github.com/jedisct1/libsodium/issues/572#issuecomment-319654932"}),"Aus einem GitHub-Kommentar von mir")),Object(l.a)("hr",null),Object(l.a)("h2",null,"zeroed_malloc"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Eigenimplementierung"),Object(l.a)("li",{parentName:"ul"},"Speichert Länge"),Object(l.a)("li",{parentName:"ul"},"Überschreibt beim deallokieren mit 0")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Erste tests auf ARM"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Erste tests auf ARM"),Object(l.a)("h3",null,"Program terminated with signal SIGBUS, Bus error."),Object(l.a)("hr",null),Object(l.a)("h2",null,"Alignment"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"void *next_aligned_address(void *pointer, size_t alignment){\n  //determine the amount of padding for proper alignment\n  size_t padding = 0; //padding needed to fit alignment\n  if (alignment != 0) {\n    padding = (alignment - (((size_t)pointer) % alignment)) % alignment;\n  }\n\n  return (char*)pointer + padding;\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Protobuf-C allocator"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"void *protobuf_c_allocator(void *allocator_data __attribute__((unused)), size_t size) {\n  return zeroed_malloc(size);\n}\n\nvoid protobuf_c_free(void *allocator_data __attribute__((unused)), void *pointer) {\n  zeroed_free(pointer);\n}\n\nstatic ProtobufCAllocator protobuf_c_allocators __attribute__((unused)) = {\n  &protobuf_c_allocator,\n  &protobuf_c_free,\n  NULL\n};\n")))}b.isMDXComponent=!0},44:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Migration"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Schritte"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"-Wc++-compat")),Object(l.a)("li",{parentName:"ul"},"Datei für Datei"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"throw"),"-Makro → ",Object(l.a)("inlineCode",{parentName:"li"},"THROW")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"NULL")," → ",Object(l.a)("inlineCode",{parentName:"li"},"nullptr")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"-Wzero-as-nullpointer-constant"))))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Schritte"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"memset")," → ",Object(l.a)("inlineCode",{parentName:"li"},"std::fill")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"memcpy")," → ",Object(l.a)("inlineCode",{parentName:"li"},"std::copy")),Object(l.a)("li",{parentName:"ul"},"Expliziter cast vor ",Object(l.a)("inlineCode",{parentName:"li"},"malloc")),Object(l.a)("li",{parentName:"ul"},"Standard-Container",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"std::vector"),", ",Object(l.a)("inlineCode",{parentName:"li"},"std::vector")," und ",Object(l.a)("inlineCode",{parentName:"li"},"std::vector")," 😁")))))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Structs → Klassen"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),'typedef struct master_keys {\n  /* ... */\n} master_keys;\n\nreturn_status master_keys_get_signing_key(\n    master_keys * const keys,\n    buffer_t * const public_signing_key) {\n  return_status status = return_status_init();\n\n  if (keys == NULL) {\n    throw(INVALID_INPUT, "keys is NULL")\n  }\n  /* ... */\n}\n')))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Structs → Klassen"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),'class MasterKeys {\n  /* ... */\n  return_status master_keys_get_signing_key(buffer_t * const public_signing_key) {\n    return_status status = return_status_init();\n\n    if (this == nullptr) { // 🤔\n      THROW(INVALID_INPUT, "keys is NULL")\n    }\n\n    /* ... */\n  }\n}\n\n')))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Schritte"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Create-Funktionen → statische Methoden → Konstruktor"),Object(l.a)("li",{parentName:"ul"},"Visibility reduzieren (public/private)"),Object(l.a)("li",{parentName:"ul"},"Copy-/Move-Assignment Operatoren/Konstruktoren")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Casts"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"-Wold-style-casts")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"static_cast")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"reinterpret_cast")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"const_cast")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"dynamic_cast")," (nie verwendet)")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"and, or, not"),Object(l.a)("p",null,"❌ gewohnt"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"if (!(a && b) || c) {\n  /* ... */\n}\n")),Object(l.a)("p",null,"✅ schöner"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"if (not (a and b) or c) {\n  /* ... */\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"alignof"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define ALIGNMENT_OF(type) offsetof( struct { char c; type t;}, t)\n")),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"alignof\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Headers"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#include <stdint.h>\n")),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"#include <cstdint>\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Referenzen"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),'return_status do_something(buffer_t *buffer) {\n  return_status status = return_status_init();\n  if (buffer == NULL) {\n    throw(INVALID_INPUT, "Buffer is missing");\n  }\n\n  /* ... */\n\ncleanup:\n  return status;\n}\n')),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"void do_something(buffer_t& buffer) {\n  /* ... */\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Goto"),Object(l.a)("p",null,"✅ Gültiges C"),Object(l.a)("p",null,"❌ Ungültiges C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"goto cleanup;\nint temporary = 42;\ncleanup:\n;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Goto"),Object(l.a)("p",null,"✅ Gültiges C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"goto cleanup;\n{\n  int temporary = 42;\n}\ncleanup:\n;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"sizeof(character)"),Object(l.a)("p",null,"x86_64"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"printf(\"%zu\", sizeof('\\0')); // 4\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"printf(\"%zu\", sizeof('\\0')); // 1\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"static_assert"),Object(l.a)("h3",null,"C (runtime)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"assert(crypto_auth_BYTES == crypto_auth_KEYBYTES);\n")),Object(l.a)("h3",null,"C++ (compile time)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"static_assert(crypto_auth_BYTES == crypto_auth_KEYBYTES);\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"RAII"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"buffer_t* buffer = buffer_create_on_heap(size, capacity);\n/* ... */\ncleanup:\n  buffer_destroy_from_heap(buffer);\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"Buffer(size, capacity);\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"RAII"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"sodium_mprotect_readonly(master_keys);\n/* ... */\nsodium_mprotect_noaccess(master_keys);\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"MasterKeys::Unlocker(master_keys) unlocker;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"RAII"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"std::unique_ptr")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"std::shared_ptr")),Object(l.a)("li",{parentName:"ul"},"⚠ ",Object(l.a)("inlineCode",{parentName:"li"},"std::bad_alloc")," fangen!")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"std::unique_ptr mit anderem Allocator"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename T>\nclass SodiumDeleter {\npublic:\n  void operator()(T* object) {\n    if (object != nullptr) {\n      sodium_free(object);\n    }\n  }\n};\n")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"this->private_keys = std::unique_ptr<PrivateKeys,SodiumDeleter<PrivateKeys>>(sodium_malloc<PrivateKeys>(1));\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"GSL"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"C++ Core Guidelines"),Object(l.a)("li",{parentName:"ul"},"Guidelines support library"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"span")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"byte")," (pre C++17)"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"narrow"))))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"GSL"),Object(l.a)("h3",null,"Vorher"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"return_status do_something(const char* bytes, size_t bytes_length);\n")),Object(l.a)("h3",null,"Nachher"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"return_status do_something(span<byte> buffer);\n")),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"😕 signed size-Typ (ständige Konvertierung zu/von ",Object(l.a)("inlineCode",{parentName:"li"},"size_t"),")")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"GSL"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"auto size = narrow<size_t>(signed_size);\n")),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Fehlerverhalten konfigurierbar (z.B. Exception)")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"templates"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"return_status endianness_uint32_to_big_endian(/* ... */);\nreturn_status endianness_int32_to_big_endian(/* ... */);\nreturn_status endianness_uint64_to_big_endian(/* ... */);\nreturn_status endianness_int64_to_big_endian(/* ... */);\n/* ... */\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename IntegerType>\nvoid to_big_endian(IntegerType integer, span<gsl::byte> output) {\n/* ... */\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"templates"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define free_and_null_if_valid(pointer)\\\n  if (pointer != NULL) {\\\n    free(pointer);\\\n    pointer = NULL;\\\n  }\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename T>\ninline void free_and_null_if_valid(T*& pointer) {\n  if (pointer != nullptr) {\n    free(pointer);\n    pointer = nullptr;\n  }\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Namespaces"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"return_status molch_create_user(/* ... */);\nreturn_status molch_list_users(/* ... */);\n")),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"namespace Molch {\n  return_status create_user(/* .. */);\n  return_status list_users(/* .. */);\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Enum Class"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Typensicherheit"),Object(l.a)("li",{parentName:"ul"},"Namespacing")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"enum class status_type {\n  SUCCESS = 0,\n  GENERIC_ERROR,\n  INVALID_VALUE,\n  INCORRECT_BUFFER_SIZE,\n  BUFFER_ERROR,\n  /* ... */\n};\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Typensichere Keys"),Object(l.a)("p",null,"Nie wieder public-/private-Key in API verwechseln"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"enum class KeyType : uint8_t {\n  /* .. */\n  PublicKey,\n  PrivateKey,\n  /* ... */\n};\n\ntemplate <size_t key_length, KeyType keytype>\nclass Key : public std::array<std::byte,key_length> {\n  /* ... */\n  template <typename DerivedKeyType>\n  result<DerivedKeyType> deriveSubkeyWithIndex(const uint32_t subkey_counter) const {\n    /* ... */\n  }\n  /* ... */\n}\n\n/* ... */\nusing PublicKey = Key<PUBLIC_KEY_SIZE,KeyType::PublicKey>;\nusing PrivateKey = Key<PRIVATE_KEY_SIZE,KeyType::PrivateKey>;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Alignment"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"std::alignof()\n")),Object(l.a)("p",null,"Eigene Implementierung fällt weg"))}],s=[{sectionTitle:"Migration"},{},{},{},{note:"Ja, ich habe tatsächlich diesen Fehler bekommen.\nUnd ja, das ist undefined behavior."},{},{},{note:"Vor allem &quot;not&quot; ist deutlich sichtbarer"},{},{},{note:"Viele NULL-Checks werden überflüssig"},{note:"Semikolon nach Goto-Label"},{},{},{},{},{note:"Ja ich weiß, das hätte man auch als Methode auf MasterKeys machen können"},{},{},{},{},{},{},{},{},{},{note:""},{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=c(e,["components"]);return Object(l.a)(p,u({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Migration"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Schritte"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"-Wc++-compat")),Object(l.a)("li",{parentName:"ul"},"Datei für Datei"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"throw"),"-Makro → ",Object(l.a)("inlineCode",{parentName:"li"},"THROW")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"NULL")," → ",Object(l.a)("inlineCode",{parentName:"li"},"nullptr")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"-Wzero-as-nullpointer-constant"))),Object(l.a)("hr",null),Object(l.a)("h2",null,"Schritte"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"memset")," → ",Object(l.a)("inlineCode",{parentName:"li"},"std::fill")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"memcpy")," → ",Object(l.a)("inlineCode",{parentName:"li"},"std::copy")),Object(l.a)("li",{parentName:"ul"},"Expliziter cast vor ",Object(l.a)("inlineCode",{parentName:"li"},"malloc")),Object(l.a)("li",{parentName:"ul"},"Standard-Container",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"std::vector"),", ",Object(l.a)("inlineCode",{parentName:"li"},"std::vector")," und ",Object(l.a)("inlineCode",{parentName:"li"},"std::vector")," 😁")))),Object(l.a)("hr",null),Object(l.a)("h2",null,"Structs → Klassen"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),'typedef struct master_keys {\n  /* ... */\n} master_keys;\n\nreturn_status master_keys_get_signing_key(\n    master_keys * const keys,\n    buffer_t * const public_signing_key) {\n  return_status status = return_status_init();\n\n  if (keys == NULL) {\n    throw(INVALID_INPUT, "keys is NULL")\n  }\n  /* ... */\n}\n')),Object(l.a)("hr",null),Object(l.a)("h2",null,"Structs → Klassen"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),'class MasterKeys {\n  /* ... */\n  return_status master_keys_get_signing_key(buffer_t * const public_signing_key) {\n    return_status status = return_status_init();\n\n    if (this == nullptr) { // 🤔\n      THROW(INVALID_INPUT, "keys is NULL")\n    }\n\n    /* ... */\n  }\n}\n\n')),Object(l.a)("hr",null),Object(l.a)("h2",null,"Schritte"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Create-Funktionen → statische Methoden → Konstruktor"),Object(l.a)("li",{parentName:"ul"},"Visibility reduzieren (public/private)"),Object(l.a)("li",{parentName:"ul"},"Copy-/Move-Assignment Operatoren/Konstruktoren")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Casts"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"-Wold-style-casts")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"static_cast")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"reinterpret_cast")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"const_cast")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"dynamic_cast")," (nie verwendet)")),Object(l.a)("hr",null),Object(l.a)("h2",null,"and, or, not"),Object(l.a)("p",null,"❌ gewohnt"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"if (!(a && b) || c) {\n  /* ... */\n}\n")),Object(l.a)("p",null,"✅ schöner"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"if (not (a and b) or c) {\n  /* ... */\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"alignof"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define ALIGNMENT_OF(type) offsetof( struct { char c; type t;}, t)\n")),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"alignof\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Headers"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#include <stdint.h>\n")),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"#include <cstdint>\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Referenzen"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),'return_status do_something(buffer_t *buffer) {\n  return_status status = return_status_init();\n  if (buffer == NULL) {\n    throw(INVALID_INPUT, "Buffer is missing");\n  }\n\n  /* ... */\n\ncleanup:\n  return status;\n}\n')),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"void do_something(buffer_t& buffer) {\n  /* ... */\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Goto"),Object(l.a)("p",null,"✅ Gültiges C"),Object(l.a)("p",null,"❌ Ungültiges C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"goto cleanup;\nint temporary = 42;\ncleanup:\n;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Goto"),Object(l.a)("p",null,"✅ Gültiges C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"goto cleanup;\n{\n  int temporary = 42;\n}\ncleanup:\n;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"sizeof(character)"),Object(l.a)("p",null,"x86_64"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"printf(\"%zu\", sizeof('\\0')); // 4\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"printf(\"%zu\", sizeof('\\0')); // 1\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"static_assert"),Object(l.a)("h3",null,"C (runtime)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"assert(crypto_auth_BYTES == crypto_auth_KEYBYTES);\n")),Object(l.a)("h3",null,"C++ (compile time)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"static_assert(crypto_auth_BYTES == crypto_auth_KEYBYTES);\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"RAII"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"buffer_t* buffer = buffer_create_on_heap(size, capacity);\n/* ... */\ncleanup:\n  buffer_destroy_from_heap(buffer);\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"Buffer(size, capacity);\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"RAII"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"sodium_mprotect_readonly(master_keys);\n/* ... */\nsodium_mprotect_noaccess(master_keys);\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"MasterKeys::Unlocker(master_keys) unlocker;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"RAII"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"std::unique_ptr")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"std::shared_ptr")),Object(l.a)("li",{parentName:"ul"},"⚠ ",Object(l.a)("inlineCode",{parentName:"li"},"std::bad_alloc")," fangen!")),Object(l.a)("hr",null),Object(l.a)("h2",null,"std::unique_ptr mit anderem Allocator"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename T>\nclass SodiumDeleter {\npublic:\n  void operator()(T* object) {\n    if (object != nullptr) {\n      sodium_free(object);\n    }\n  }\n};\n")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"this->private_keys = std::unique_ptr<PrivateKeys,SodiumDeleter<PrivateKeys>>(sodium_malloc<PrivateKeys>(1));\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"GSL"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"C++ Core Guidelines"),Object(l.a)("li",{parentName:"ul"},"Guidelines support library"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"span")),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"byte")," (pre C++17)"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"narrow"))),Object(l.a)("hr",null),Object(l.a)("h2",null,"GSL"),Object(l.a)("h3",null,"Vorher"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"return_status do_something(const char* bytes, size_t bytes_length);\n")),Object(l.a)("h3",null,"Nachher"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"return_status do_something(span<byte> buffer);\n")),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"😕 signed size-Typ (ständige Konvertierung zu/von ",Object(l.a)("inlineCode",{parentName:"li"},"size_t"),")")),Object(l.a)("hr",null),Object(l.a)("h2",null,"GSL"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"auto size = narrow<size_t>(signed_size);\n")),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Fehlerverhalten konfigurierbar (z.B. Exception)")),Object(l.a)("hr",null),Object(l.a)("h2",null,"templates"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"return_status endianness_uint32_to_big_endian(/* ... */);\nreturn_status endianness_int32_to_big_endian(/* ... */);\nreturn_status endianness_uint64_to_big_endian(/* ... */);\nreturn_status endianness_int64_to_big_endian(/* ... */);\n/* ... */\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename IntegerType>\nvoid to_big_endian(IntegerType integer, span<gsl::byte> output) {\n/* ... */\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"templates"),Object(l.a)("h3",null,"❌ C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"#define free_and_null_if_valid(pointer)\\\n  if (pointer != NULL) {\\\n    free(pointer);\\\n    pointer = NULL;\\\n  }\n")),Object(l.a)("h3",null,"✅ C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename T>\ninline void free_and_null_if_valid(T*& pointer) {\n  if (pointer != nullptr) {\n    free(pointer);\n    pointer = nullptr;\n  }\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Namespaces"),Object(l.a)("h3",null,"C"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"return_status molch_create_user(/* ... */);\nreturn_status molch_list_users(/* ... */);\n")),Object(l.a)("h3",null,"C++"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-c"}),"namespace Molch {\n  return_status create_user(/* .. */);\n  return_status list_users(/* .. */);\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Enum Class"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Typensicherheit"),Object(l.a)("li",{parentName:"ul"},"Namespacing")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"enum class status_type {\n  SUCCESS = 0,\n  GENERIC_ERROR,\n  INVALID_VALUE,\n  INCORRECT_BUFFER_SIZE,\n  BUFFER_ERROR,\n  /* ... */\n};\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Typensichere Keys"),Object(l.a)("p",null,"Nie wieder public-/private-Key in API verwechseln"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"enum class KeyType : uint8_t {\n  /* .. */\n  PublicKey,\n  PrivateKey,\n  /* ... */\n};\n\ntemplate <size_t key_length, KeyType keytype>\nclass Key : public std::array<std::byte,key_length> {\n  /* ... */\n  template <typename DerivedKeyType>\n  result<DerivedKeyType> deriveSubkeyWithIndex(const uint32_t subkey_counter) const {\n    /* ... */\n  }\n  /* ... */\n}\n\n/* ... */\nusing PublicKey = Key<PUBLIC_KEY_SIZE,KeyType::PublicKey>;\nusing PrivateKey = Key<PRIVATE_KEY_SIZE,KeyType::PrivateKey>;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Alignment"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"std::alignof()\n")),Object(l.a)("p",null,"Eigene Implementierung fällt weg"))}b.isMDXComponent=!0},45:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Wieder Error Handling"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Wrapper um return_status"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"struct Error {\n  status_type type{type::status::SUCCESS};\n  std::string message;\n\n  Error(const status_type type, const std::string& message);\n  /* ... */\n}\n\nclass Exception : public std::exception {\nprivate:\n  std::deque<Error> error_stack;\n  mutable std::string printed;\n\npublic:\n  Exception(const Error& error);\n  Exception(const status_type type, const std::string& message);\n  Exception(return_status& status);\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Entfernen des Error-Stacks"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Die Katastrophe passiert"),Object(l.a)("h3",null,"Ich kann keine Exceptions mehr verwenden"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"SEGFAULT beim throwen")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Ich kann keine Exceptions mehr verwenden"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Keine Fehler mehr in Konstruktoren möglich")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Boost Outcome to the rescue"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename Result>\nusing result = outcome::result<Result,Error>;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Private unvollständige Konstruktoren"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"// Marker-Typ\nstruct uninitialized_t {\n explicit uninitialized_t() = default;\n};\n\nclass MasterKeys {\n  /* ... */\nprivate:\n  MasterKeys(uninitialized_t uninitialized) noexcept;\n  /* ... */\npublic:\n        static result<MasterKeys> create(/* ... */);\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Fehlerpropagierung"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"OUTCOME_TRY(do_something());\nOUTCOME_TRY(value, calculate_something());\n")))}],s=[{},{},{},{note:"Because: Android is weird"},{},{},{note:"Marker um vom Default-Konstruktor zu unterscheiden"},{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=c(e,["components"]);return Object(l.a)(p,u({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Wieder Error Handling"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Wrapper um return_status"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"struct Error {\n  status_type type{type::status::SUCCESS};\n  std::string message;\n\n  Error(const status_type type, const std::string& message);\n  /* ... */\n}\n\nclass Exception : public std::exception {\nprivate:\n  std::deque<Error> error_stack;\n  mutable std::string printed;\n\npublic:\n  Exception(const Error& error);\n  Exception(const status_type type, const std::string& message);\n  Exception(return_status& status);\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Entfernen des Error-Stacks"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Die Katastrophe passiert"),Object(l.a)("h3",null,"Ich kann keine Exceptions mehr verwenden"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"SEGFAULT beim throwen")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Ich kann keine Exceptions mehr verwenden"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Keine Fehler mehr in Konstruktoren möglich")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Boost Outcome to the rescue"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"template <typename Result>\nusing result = outcome::result<Result,Error>;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Private unvollständige Konstruktoren"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"// Marker-Typ\nstruct uninitialized_t {\n explicit uninitialized_t() = default;\n};\n\nclass MasterKeys {\n  /* ... */\nprivate:\n  MasterKeys(uninitialized_t uninitialized) noexcept;\n  /* ... */\npublic:\n        static result<MasterKeys> create(/* ... */);\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Fehlerpropagierung"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"OUTCOME_TRY(do_something());\nOUTCOME_TRY(value, calculate_something());\n")))}b.isMDXComponent=!0},46:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Wieder Serialisierung"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Protobuf C++-Library"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"API benutzt std::string für bytes",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"⇒ Alle keys auf normalem Heap"))),Object(l.a)("li",{parentName:"ul"},'"hübsche API" macht Allocator-Tausch sinnlos')))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Arena-Allocator"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Anfangs selbst implementiert"),Object(l.a)("li",{parentName:"ul"},"Später mit Google-Protobuf-Library"),Object(l.a)("li",{parentName:"ul"},"Eine Arena pro Serialisierung-/Deserialisiserung"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"sodium_malloc")," plötzlich eine Option"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"zeroed_malloc")," gelöscht")))}],s=[{sectionTitle:"Wieder Serialisierung"},{},{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=u(e,["components"]);return Object(l.a)(p,c({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Wieder Serialisierung"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Protobuf C++-Library"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"API benutzt std::string für bytes",Object(l.a)("ul",{parentName:"li"},Object(l.a)("li",{parentName:"ul"},"⇒ Alle keys auf normalem Heap"))),Object(l.a)("li",{parentName:"ul"},'"hübsche API" macht Allocator-Tausch sinnlos')),Object(l.a)("hr",null),Object(l.a)("h2",null,"Arena-Allocator"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Anfangs selbst implementiert"),Object(l.a)("li",{parentName:"ul"},"Später mit Google-Protobuf-Library"),Object(l.a)("li",{parentName:"ul"},"Eine Arena pro Serialisierung-/Deserialisiserung"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"sodium_malloc")," plötzlich eine Option"),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"zeroed_malloc")," gelöscht")))}b.isMDXComponent=!0},47:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Modern C++ Tidbits"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Switch Case"),Object(l.a)("h3",null,"Alt"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"char digit;\nswitch (ternary) {\n  case 0:\n    digit = '0';\n    break;\n\n  case 1:\n    digit = '1';\n    break;\n\n  case 2:\n    digit = '2';\n    break;\n\n  default:\n    std::terminate();\n}\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"Switch Case"),Object(l.a)("h3",null,"Neu (IIFE)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"const char digit = [=]{\n  switch (ternary) {\n    case 0:\n      return '0';\n\n    case 1:\n      return '1';\n\n    case 2:\n      return '2';\n\n    default:\n      std::terminate();\n  }\n}();\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"if-Expression"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"const char digit = [=]{\n  if (binary) {\n    return '1';\n  } else {\n    return '0';\n  }\n}();\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"std::optional"),Object(l.a)("p",null,Object(l.a)("strong",{parentName:"p"},"Clunky und Fehleranfällig")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"auto data_optional = get_data();\nif (not data_optional.has_value()) {\n  return std::nullopt;\n}\nauto& data = *data_optional;\n")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"std::span"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Laufzeit-Check unmöglich."),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"subspan")," ist undefined wenn out of range")))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h2",null,"max_align_t (C++17)"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"alignof(max_align_t)")," Maximal mögliches Alignment"),Object(l.a)("li",{parentName:"ul"},"Früher simuliert durch ",Object(l.a)("inlineCode",{parentName:"li"},"int_max_t")," aber nicht durch Standard garantiert.")))}],s=[{sectionTitle:"Modern C++ Tidbits"},{},{note:"Immediately Invoked Function Expression"},{},{},{},{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=c(e,["components"]);return Object(l.a)(p,u({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Modern C++ Tidbits"),Object(l.a)("hr",null),Object(l.a)("h2",null,"Switch Case"),Object(l.a)("h3",null,"Alt"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"char digit;\nswitch (ternary) {\n  case 0:\n    digit = '0';\n    break;\n\n  case 1:\n    digit = '1';\n    break;\n\n  case 2:\n    digit = '2';\n    break;\n\n  default:\n    std::terminate();\n}\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"Switch Case"),Object(l.a)("h3",null,"Neu (IIFE)"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"const char digit = [=]{\n  switch (ternary) {\n    case 0:\n      return '0';\n\n    case 1:\n      return '1';\n\n    case 2:\n      return '2';\n\n    default:\n      std::terminate();\n  }\n}();\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"if-Expression"),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"const char digit = [=]{\n  if (binary) {\n    return '1';\n  } else {\n    return '0';\n  }\n}();\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"std::optional"),Object(l.a)("p",null,Object(l.a)("strong",{parentName:"p"},"Clunky und Fehleranfällig")),Object(l.a)("pre",null,Object(l.a)("code",u({parentName:"pre"},{className:"language-cpp"}),"auto data_optional = get_data();\nif (not data_optional.has_value()) {\n  return std::nullopt;\n}\nauto& data = *data_optional;\n")),Object(l.a)("hr",null),Object(l.a)("h2",null,"std::span"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},"Laufzeit-Check unmöglich."),Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"subspan")," ist undefined wenn out of range")),Object(l.a)("hr",null),Object(l.a)("h2",null,"max_align_t (C++17)"),Object(l.a)("ul",null,Object(l.a)("li",{parentName:"ul"},Object(l.a)("inlineCode",{parentName:"li"},"alignof(max_align_t)")," Maximal mögliches Alignment"),Object(l.a)("li",{parentName:"ul"},"Früher simuliert durch ",Object(l.a)("inlineCode",{parentName:"li"},"int_max_t")," aber nicht durch Standard garantiert.")))}b.isMDXComponent=!0},48:function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return i}),t.d(n,"fusumaProps",function(){return s}),t.d(n,"default",function(){return b});var a=t(2),r=t.n(a),l=t(0);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=[function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Rückblick"))},function(e){return Object(l.a)(r.a.Fragment,null,Object(l.a)("h1",null,"Ende"))}],s=[{sectionTitle:"Rückblick"},{}],o={slides:i},p="wrapper";function b(e){var n=e.components,t=u(e,["components"]);return Object(l.a)(p,c({},o,t,{components:n,mdxType:"MDXLayout"}),Object(l.a)("h1",null,"Rückblick"),Object(l.a)("hr",null),Object(l.a)("h1",null,"Ende"))}b.isMDXComponent=!0}},[[13,5,6]],[0,8]]);